<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLMè‡ªå¾‹è­°è«–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ (ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¯¾å¿œç‰ˆ)</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f0f2f5;
            color: #333;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        .turn-counter {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #sidebar {
            width: 340px;
            padding: 20px;
            background-color: #ffffff;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        #chat-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            background-color: #e9ecef;
            position: relative;
        }
        #chat-window {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            scroll-behavior: smooth;
        }
        .chat-message {
            margin-bottom: 20px;
            padding: 15px 20px;
            border-radius: 12px;
            max-width: 85%;
            line-height: 1.7;
            position: relative;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            word-wrap: break-word;
        }
        
        .chat-message strong {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            opacity: 0.9;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 4px;
        }

        /* å½¹å‰²ã”ã¨ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
        .role-moderator { background-color: #e0f7fa; border-left: 5px solid #00bcd4; color: #006064; align-self: flex-start; }
        .role-market { background-color: #fff9c4; border-left: 5px solid #fbc02d; color: #f57f17; align-self: flex-start; }
        .role-translator { background-color: #f3e5f5; border-left: 5px solid #ab47bc; color: #4a148c; align-self: flex-start; }
        .role-scout { background-color: #ffe0b2; border-left: 5px solid #ff9800; color: #e65100; align-self: flex-start; }
        .role-creator { background-color: #c8e6c9; border-left: 5px solid #4caf50; color: #1b5e20; align-self: flex-start; }
        .role-expert { background-color: #d1e7ff; border-right: 5px solid #2979ff; color: #0d47a1; align-self: flex-end; margin-left: auto;}
        .role-system { background-color: #f8f9fa; border: 1px solid #dee2e6; width: 90%; margin: 10px auto; text-align: center; font-size: 0.85em; color: #6c757d; }
        .role-error { background-color: #ffebee; border: 1px solid #ffcdd2; color: #c62828; width: 90%; margin: 10px auto; text-align: center;}

        /* ã‚µã‚¤ãƒ‰ãƒãƒ¼è¦ç´  */
        .control-section { margin-bottom: 25px; border-bottom: 1px solid #f0f0f0; padding-bottom: 15px; }
        .control-section:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.9em; color: #555; }
        input[type="password"], input[type="text"], textarea {
            width: 100%; box-sizing: border-box; padding: 10px; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 10px; font-size: 14px;
        }
        
        button {
            width: 100%; padding: 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 8px; transition: all 0.2s; font-size: 14px;
        }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        
        .btn-start { background-color: #28a745; color: white; }
        .btn-stop { background-color: #dc3545; color: white; }
        .btn-continue { background-color: #17a2b8; color: white; }
        .btn-summary { background-color: #6c757d; color: white; }
        .btn-expert { background-color: #007bff; color: white; }
        .btn-export { background-color: #343a40; color: white; }

        .typing-indicator {
            padding: 10px; font-style: italic; color: #888; font-size: 0.9em; display: none;
            position: absolute; bottom: 10px; left: 20px; background: rgba(255,255,255,0.8); border-radius: 4px;
        }
        
        /* ã‚«ãƒ¼ã‚½ãƒ«ç‚¹æ»…ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ä¸­ç”¨ï¼‰ */
        .cursor::after { content: "â–‹"; animation: blink 1s step-start infinite; color: #333; margin-left: 2px; }
        @keyframes blink { 50% { opacity: 0; } }

    </style>
</head>
<body>

    <header>
        <h1>ğŸ¤– AI Boardroom Simulator (Streaming)</h1>
        <div class="turn-counter">Turn: <span id="turn-count">0</span> / 10</div>
    </header>

    <div class="container">
        <aside id="sidebar">
            <div class="control-section">
                <label>API Keys</label>
                <input type="password" id="openai-key" placeholder="OpenAI Key (sk-...)">
                <input type="password" id="gemini-key" placeholder="Gemini Key (AIza...)">
            </div>

            <div class="control-section">
                <label>è­°è«–ãƒ†ãƒ¼ãƒ</label>
                <input type="text" id="discussion-topic" value="æ¬¡ä¸–ä»£ã®è»½é‡é«˜å¼·åº¦ææ–™ã®ç ”ç©¶é–‹ç™ºæˆ¦ç•¥">
            </div>

            <div class="control-section" id="auto-controls">
                <label>ã‚ªãƒ¼ãƒˆæ“ä½œ</label>
                <button id="btn-auto-start" class="btn-start">â–¶ è‡ªå‹•è­°è«–ã‚’é–‹å§‹</button>
                
                <div id="pause-menu" style="display:none; margin-top: 10px; padding: 10px; background: #fff3e0; border-radius: 5px;">
                    <p style="font-size:0.8em; text-align:center; color:#e65100; margin: 0 0 10px 0; font-weight: bold;">è¦å®šå›æ•°ã«é”ã—ã¾ã—ãŸ</p>
                    <button id="btn-auto-continue" class="btn-continue">ğŸ”„ è­°è«–ã‚’ç¶™ç¶š (+10å›)</button>
                    <button id="btn-auto-summary" class="btn-summary">ğŸ“ ã¾ã¨ã‚ã‚’ä½œæˆã—ã¦çµ‚äº†</button>
                </div>
                
                <button id="btn-force-stop" class="btn-stop" style="display:none;">â¹ å¼·åˆ¶åœæ­¢</button>
            </div>

            <div class="control-section">
                <label>ã‚µãƒãƒªãƒ¼å‡ºåŠ›</label>
                <button id="btn-export-txt" class="btn-export" disabled>ğŸ“„ ã‚µãƒãƒªãƒ¼ã‚’ .txt ã§ä¿å­˜</button>
                <button id="btn-export-doc" class="btn-export" disabled>ğŸ“„ ã‚µãƒãƒªãƒ¼ã‚’ .doc ã§ä¿å­˜</button>
                <p style="font-size:0.8em; color:#666; margin-top:4px;">
                    â€» .doc ã‚‚ä¸­èº«ã¯ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã™ãŒã€Wordç­‰ã§ãã®ã¾ã¾é–‹ã‘ã¾ã™ã€‚
                </p>
            </div>

            <div class="expert-panel" style="margin-top: auto;">
                <label>ã‚ãªãŸ (ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ)</label>
                <textarea id="expert-input" rows="4" placeholder="è‡ªå‹•é€²è¡Œä¸­ã§ã‚‚æŒ‡åã•ã‚ŒãŸã‚‰ã“ã“ã«å…¥åŠ›..." disabled></textarea>
                <button id="btn-expert" class="btn-expert" disabled>å›ç­”ã‚’é€ã‚‹</button>
            </div>
        </aside>

        <main id="chat-container">
            <div id="chat-window"></div>
            <div id="typing-indicator" class="typing-indicator">Thinking...</div>
        </main>
    </div>

    <script>
        // --- å®šæ•°ãƒ»çŠ¶æ…‹å¤‰æ•° ---
        const MAX_TURNS_PER_ROUND = 10;
        const GEMINI_MODEL_NAME = "gemini-1.5-pro";

        let currentTurnCount = 0;
        let isAutoMode = false;
        let discussionHistory = []; // {role: str, content: str}
        let openAiApiKey = '';
        let geminiApiKey = '';
        let discussionTopic = '';
        let lastSummaryText = ""; // ã‚µãƒãƒªãƒ¼ã®ç”Ÿãƒ†ã‚­ã‚¹ãƒˆ

        // DOMè¦ç´ 
        const chatWindow = document.getElementById('chat-window');
        const typingIndicator = document.getElementById('typing-indicator');
        const turnDisplay = document.getElementById('turn-count');
        
        const inputs = {
            openai: document.getElementById('openai-key'),
            gemini: document.getElementById('gemini-key'),
            topic: document.getElementById('discussion-topic'),
            expert: document.getElementById('expert-input')
        };

        const buttons = {
            startAuto: document.getElementById('btn-auto-start'),
            continueAuto: document.getElementById('btn-auto-continue'),
            summaryAuto: document.getElementById('btn-auto-summary'),
            forceStop: document.getElementById('btn-force-stop'),
            expert: document.getElementById('btn-expert'),
            exportTxt: document.getElementById('btn-export-txt'),
            exportDoc: document.getElementById('btn-export-doc')
        };

        const panels = {
            pauseMenu: document.getElementById('pause-menu')
        };

        // --- ãƒšãƒ«ã‚½ãƒŠå®šç¾© ---
        const PERSONAS_TEMPLATE = {
            "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼": {
                api: "gemini",
                roleName: "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼",
                basePrompt: `ã‚ãªãŸã¯ã€è­°è«–ã®ã€Œãƒ—ãƒ­ã‚»ã‚¹ã€ã‚’ç®¡ç†ã™ã‚‹å„ªç§€ãªãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚
â€¢ å½¹å‰²: è­°è«–ã®æŒ‡æ®è€…
â€¢ ãƒŸãƒƒã‚·ãƒ§ãƒ³:
  1. è­°è«–ã®ç›®çš„ï¼ˆ{TOPIC}ï¼‰ã«å‘ã‘ã€å‚åŠ è€…ã‹ã‚‰æ„è¦‹ã‚’å¼•ãå‡ºã™ã€‚
  2. ã‚ãªãŸãŒè­°è«–ã‚’å›ã—ã¾ã™ã€‚ä»–ã®å‚åŠ è€…ãŒç™ºè¨€ã—ãŸå¾Œã€ã‚ãªãŸã¯å¿…ãšãã®ç™ºè¨€ã‚’å—ã‘ã¦æ•´ç†ã—ã€**æ¬¡ã«èª°ãŒç™ºè¨€ã™ã¹ãã‹**ã‚’æ±ºå®šã—ã¾ã™ã€‚
  3. è­°è«–ã®æœ€åˆã¯ã€ã¾ãšã€Œãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰ã€ã«å¯¾ã—ã¦ã€ãƒ†ãƒ¼ãƒã®èƒŒæ™¯ã‚„ç¾çŠ¶ã®èª²é¡Œã‚’æ·±æ˜ã‚Šã™ã‚‹è³ªå•ã‚’æŠ•ã’ã‹ã‘ã¦ãã ã•ã„ã€‚

â€¢ é‡è¦: æ¬¡ã®ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã®æŒ‡åæ–¹æ³•
  ç™ºè¨€ã®æœ€å¾Œã«ã€å¿…ãšä»¥ä¸‹ã®å½¢å¼ã§æ¬¡ã«ç™ºè¨€ã—ã¦ã»ã—ã„å½¹å‰²åã‚’ä¸€ã¤ã ã‘æŒ‡å®šã—ã¦ãã ã•ã„ï¼ˆæ–‡è„ˆã«å¿œã˜ã¦æœ€é©ãªäººç‰©ã‚’é¸ã‚“ã§ãã ã•ã„ï¼‰ã€‚
  å‡ºåŠ›å½¢å¼: [[NEXT: å½¹å‰²å]]
  
  â€»é¸æŠå¯èƒ½ãªå½¹å‰²å:
  - ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ (äººé–“ã«æ„è¦‹ã‚’èãå ´åˆ)
  - ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ (æœªæ¥ã®é¡§å®¢ãƒ‹ãƒ¼ã‚º)
  - ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚¿ãƒ¼ (æŠ€è¡“è¦ä»¶)
  - ã‚¢ã‚»ãƒƒãƒˆãƒ»ã‚¹ã‚«ã‚¦ãƒˆ (å¤–éƒ¨æŠ€è¡“ãƒ»ç«¶åˆ)
  - ãƒ“ã‚¸ãƒã‚¹ãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼ (äº‹æ¥­åŒ–ãƒ»å‡ºå£)

â€¢ è¡Œå‹•åˆ¶ç´„: è‡ªåˆ†ã®æ„è¦‹ã¯è¨€ã‚ãšã€é€²è¡Œã«å¾¹ã™ã‚‹ã€‚
â€¢ å£èª¿: å†·é™æ²ˆç€ã€ä¸­ç«‹çš„ã€çŸ¥çš„ã€‚`
            },
            "ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ": {
                api: "openai",
                roleName: "ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ",
                basePrompt: `ã‚ãªãŸã¯ã€Œæœªæ¥ã®é¡§å®¢ã®ä»£å¼è€…ã€ã§ã™ã€‚
â€¢ ãƒŸãƒƒã‚·ãƒ§ãƒ³: æŠ€è¡“çš„åˆ¶ç´„ã‚’ç„¡è¦–ã—ã€5-10å¹´å¾Œã®ç†æƒ³ã®æœªæ¥ã¨é¡§å®¢ã®ãƒšã‚¤ãƒ³ã‚’å®šç¾©ã™ã‚‹ã€‚
â€¢ ãŠé¡Œ: {TOPIC}
â€¢ å£èª¿: ãƒ“ã‚¸ãƒ§ãƒŠãƒªãƒ¼ã€æƒ…ç†±çš„ã€æ–­å®šçš„ã€‚ã€Œã€œã¹ãã ã€`
            },
            "ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚¿ãƒ¼": {
                api: "gemini",
                roleName: "ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚¿ãƒ¼",
                basePrompt: `ã‚ãªãŸã¯ã€Œãƒ‹ãƒ¼ã‚ºã¨æŠ€è¡“ã®ç¿»è¨³å®¶ã€ã§ã™ã€‚
â€¢ ãƒŸãƒƒã‚·ãƒ§ãƒ³: æŠ½è±¡çš„ãªãƒ‹ãƒ¼ã‚ºã‚’å…·ä½“çš„ãªæŠ€è¡“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚„æ©Ÿèƒ½è¦ä»¶ã«åˆ†è§£ã™ã‚‹ã€‚
â€¢ ãŠé¡Œ: {TOPIC}
â€¢ å£èª¿: è«–ç†çš„ã€åˆ†æçš„ã€‚ã€Œã¤ã¾ã‚Šã€ã€Œè¦ã™ã‚‹ã«ã€`
            },
            "ã‚¢ã‚»ãƒƒãƒˆãƒ»ã‚¹ã‚«ã‚¦ãƒˆ": {
                api: "gemini",
                roleName: "ã‚¢ã‚»ãƒƒãƒˆãƒ»ã‚¹ã‚«ã‚¦ãƒˆ",
                basePrompt: `ã‚ãªãŸã¯ã€Œå¤–éƒ¨æŠ€è¡“ã®ç›£è¦–è€…ã€ã§ã™ã€‚
â€¢ ãƒŸãƒƒã‚·ãƒ§ãƒ³: ç«¶åˆã€ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã€ç‰¹è¨±ãªã©ã®å¤–éƒ¨å‹•å‘ï¼ˆæ¶ç©ºå¯ï¼‰ã‚’æç¤ºã—ã€Buy or Buildã‚’åˆ¤æ–­ã™ã‚‹ã€‚
â€¢ ãŠé¡Œ: {TOPIC}
â€¢ å£èª¿: ãƒ‡ãƒ¼ã‚¿ãƒ‰ãƒªãƒ–ãƒ³ã€è¾›å£ã€æ—©å£ã€‚`
            },
            "ãƒ“ã‚¸ãƒã‚¹ãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼": {
                api: "openai",
                roleName: "ãƒ“ã‚¸ãƒã‚¹ãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼",
                basePrompt: `ã‚ãªãŸã¯ã€Œäº‹æ¥­ã¨å‡ºå£ã®è¨­è¨ˆè€…ã€ã§ã™ã€‚
â€¢ ãƒŸãƒƒã‚·ãƒ§ãƒ³: å…¨ã¦ã®è¦ç´ ã‚’çµ±åˆã—ã€ãƒãƒã‚¿ã‚¤ã‚ºãƒ¢ãƒ‡ãƒ«ã¨å‡ºå£æˆ¦ç•¥ï¼ˆM&Aãªã©ï¼‰ã‚’æãã€‚
â€¢ ãŠé¡Œ: {TOPIC}
â€¢ å£èª¿: èµ·æ¥­å®¶çš„ã€åç›Šå¿—å‘ã€ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–ã€‚`
            },
            "ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ": {
                api: "user",
                roleName: "ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ"
            }
        };

        // å®Ÿéš›ã«ä½¿ã† PERSONASï¼ˆinitializeSystem å†…ã§ãƒˆãƒ”ãƒƒã‚¯åŸ‹ã‚è¾¼ã¿ï¼‰
        let PERSONAS = {};

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---

        buttons.startAuto.addEventListener('click', () => {
            if (!initializeSystem()) return;
            startAutoMode();
        });

        buttons.continueAuto.addEventListener('click', () => {
            currentTurnCount = 0; 
            updateTurnDisplay();
            panels.pauseMenu.style.display = 'none';
            buttons.forceStop.style.display = 'inline-block';
            orchestrateNextTurn("ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼");
        });

        buttons.summaryAuto.addEventListener('click', async () => {
            panels.pauseMenu.style.display = 'none';
            buttons.forceStop.style.display = 'none';
            await generateSummary();
        });

        buttons.forceStop.addEventListener('click', () => {
            isAutoMode = false;
            buttons.forceStop.style.display = 'none';
            panels.pauseMenu.style.display = 'block'; 
            addSystemMessage('è‡ªå‹•é€²è¡Œã‚’å¼·åˆ¶åœæ­¢ã—ã¾ã—ãŸã€‚');
        });

        buttons.expert.addEventListener('click', () => {
            const content = inputs.expert.value;
            if (!content) return;

            addMessageToChat("ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ", content);
            discussionHistory.push({ role: "ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ", content: content });
            inputs.expert.value = '';
            inputs.expert.disabled = true;
            buttons.expert.disabled = true;

            if (isAutoMode) {
                orchestrateNextTurn("ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼");
            }
        });

        buttons.exportTxt.addEventListener('click', () => downloadSummaryAs('txt'));
        buttons.exportDoc.addEventListener('click', () => downloadSummaryAs('doc'));

        // --- ã‚³ã‚¢ãƒ­ã‚¸ãƒƒã‚¯ ---

        function initializeSystem() {
            openAiApiKey = inputs.openai.value;
            geminiApiKey = inputs.gemini.value;
            discussionTopic = inputs.topic.value;

            if (!openAiApiKey || !geminiApiKey) {
                alert("APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„ã€‚");
                return false;
            }

            // ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‹ã‚‰ PERSONAS ã‚’å†æ§‹æˆï¼ˆæ¯å›ãƒªã‚»ãƒƒãƒˆï¼‰
            PERSONAS = {};
            Object.keys(PERSONAS_TEMPLATE).forEach(key => {
                const template = PERSONAS_TEMPLATE[key];
                if (!template.basePrompt) {
                    PERSONAS[key] = { api: template.api, roleName: template.roleName };
                } else {
                    PERSONAS[key] = {
                        api: template.api,
                        roleName: template.roleName,
                        prompt: template.basePrompt.replace(/\{TOPIC\}/g, discussionTopic)
                    };
                }
            });

            // ã‚µãƒãƒªãƒ¼çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
            lastSummaryText = "";
            buttons.exportTxt.disabled = true;
            buttons.exportDoc.disabled = true;

            return true;
        }

        function startAutoMode() {
            isAutoMode = true;
            discussionHistory = [];
            chatWindow.innerHTML = '';
            currentTurnCount = 0;
            updateTurnDisplay();

            buttons.startAuto.style.display = 'none';
            buttons.forceStop.style.display = 'inline-block';
            panels.pauseMenu.style.display = 'none';

            addSystemMessage(`è­°è«–ã€Œ${discussionTopic}ã€ã‚’é–‹å§‹ã—ã¾ã™ã€‚`);
            orchestrateNextTurn("ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼");
        }

        async function orchestrateNextTurn(roleName) {
            if (!isAutoMode) return;

            if (currentTurnCount >= MAX_TURNS_PER_ROUND) {
                pauseAutoMode();
                return;
            }

            if (roleName === "ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ") {
                addSystemMessage('>> ã‚ãªãŸã®ç•ªã§ã™ã€‚å›ç­”ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚');
                inputs.expert.disabled = false;
                buttons.expert.disabled = false;
                inputs.expert.focus();
                return; 
            }

            try {
                showTyping(true, roleName);
                const content = await streamLLM(roleName);
                showTyping(false);

                discussionHistory.push({ role: roleName, content: content });
                currentTurnCount++;
                updateTurnDisplay();

                if (roleName === "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼") {
                    const nextMatch = content.match(/\[\[NEXT:\s*(.+?)\]\]/);
                    if (nextMatch && nextMatch[1]) {
                        let nextRole = nextMatch[1].trim();
                        if (!PERSONAS[nextRole]) {
                            console.warn(`Unknown role: ${nextRole}. Continuing Moderator.`);
                            nextRole = "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼";
                        }
                        setTimeout(() => orchestrateNextTurn(nextRole), 800);
                    } else {
                        setTimeout(() => orchestrateNextTurn("ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼"), 800);
                    }
                } else {
                    setTimeout(() => orchestrateNextTurn("ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼"), 800);
                }

            } catch (e) {
                showTyping(false);
                addErrorMessage(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`);
                console.error(e);
                isAutoMode = false;
                buttons.forceStop.style.display = 'none';
                buttons.startAuto.style.display = 'inline-block';
            }
        }

        function pauseAutoMode() {
            buttons.forceStop.style.display = 'none';
            panels.pauseMenu.style.display = 'block';
        }

        // --- ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°APIå‘¼ã³å‡ºã— (Core) ---

        async function streamLLM(roleName) {
            const persona = PERSONAS[roleName];
            const messageDiv = createMessageDiv(roleName);
            const contentSpan = document.createElement('span');
            contentSpan.classList.add('cursor');
            messageDiv.appendChild(contentSpan);
            chatWindow.scrollTop = chatWindow.scrollHeight;

            let fullText = "";

            if (persona.api === 'openai') {
                fullText = await streamOpenAI(persona, contentSpan);
            } else {
                fullText = await streamGemini(persona, contentSpan);
            }

            contentSpan.classList.remove('cursor');
            return fullText;
        }

        async function streamGemini(persona, targetElement) {
            let contents = formatHistoryForGemini(discussionHistory);

            if (contents.length === 0) {
                contents.push({
                    role: "user",
                    parts: [{ text: `è­°è«–é–‹å§‹: ${discussionTopic}\nã‚ãªãŸã®å½¹å‰²ã¨ã—ã¦è­°è«–ã‚’ãƒªãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚` }]
                });
            }

            const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:streamGenerateContent?alt=sse&key=${encodeURIComponent(geminiApiKey)}`;
            
            const safetySettings = [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }
            ];

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: contents,
                    systemInstruction: { parts: [{ text: persona.prompt }] },
                    generationConfig: { temperature: 0.7 },
                    safetySettings: safetySettings
                })
            });

            if (!response.ok) {
                let errText = await response.text();
                throw new Error(`Gemini Error ${response.status}: ${errText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            let fullText = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (!line.startsWith('data: ')) continue;
                    const jsonStr = line.slice(6).trim();
                    if (!jsonStr || jsonStr === '[DONE]') continue;
                    let data;
                    try {
                        data = JSON.parse(jsonStr);
                    } catch (e) {
                        continue;
                    }
                    const cand = data.candidates && data.candidates[0];
                    const parts = cand && cand.content && Array.isArray(cand.content.parts) ? cand.content.parts : null;
                    if (!parts || parts.length === 0) continue;

                    for (const part of parts) {
                        if (!part || typeof part.text !== 'string') continue;
                        fullText += part.text;
                    }

                    targetElement.innerHTML = fullText.replace(/\n/g, '<br>');
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
            }
            return fullText;
        }

        async function streamOpenAI(persona, targetElement) {
            let messages = [
                { role: "system", content: persona.prompt },
                ...formatHistoryForOpenAI(discussionHistory)
            ];

            if (messages.length === 1) {
                messages.push({ role: "user", content: `è­°è«–é–‹å§‹: ${discussionTopic}` });
            }

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${openAiApiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-4o",
                    messages: messages,
                    temperature: 0.7,
                    stream: true
                })
            });

            if (!response.ok) {
                let errText = await response.text();
                throw new Error(`OpenAI Error ${response.status}: ${errText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = "";
            let finalAccumulatedText = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                
                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop();

                for (const line of lines) {
                    if (!line.startsWith('data: ')) continue;
                    const jsonStr = line.slice(6).trim();
                    if (!jsonStr || jsonStr === '[DONE]') continue;
                    let data;
                    try {
                        data = JSON.parse(jsonStr);
                    } catch (e) {
                        continue;
                    }
                    if (!data.choices || !data.choices[0] || !data.choices[0].delta) continue;
                    const delta = data.choices[0].delta;
                    if (!delta.content) continue;
                    const textChunk = delta.content;
                    finalAccumulatedText += textChunk;
                    targetElement.innerHTML = finalAccumulatedText.replace(/\n/g, '<br>');
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
            }
            return finalAccumulatedText;
        }

        // --- ã¾ã¨ã‚ç”Ÿæˆï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ç‰ˆï¼‰ ---
        async function generateSummary() {
            showTyping(true, "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ (ã¾ã¨ã‚ä½œæˆä¸­)");
            
            try {
                const roleName = "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼";
                const messageDiv = createMessageDiv(roleName);
                const contentSpan = document.createElement('span');
                contentSpan.classList.add('cursor');
                messageDiv.appendChild(contentSpan);
                chatWindow.scrollTop = chatWindow.scrollHeight;

                let tempHistory = [...discussionHistory];
                tempHistory.push({role: "user", content: "ã“ã‚Œã¾ã§ã®è­°è«–å…¨ä½“ã‚’æ•´ç†ã—ã€æ±ºå®šäº‹é …ã€æ®‹ã•ã‚ŒãŸèª²é¡Œã€ãƒã‚¯ã‚¹ãƒˆã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã¾ã¨ã‚ãŸã‚µãƒãƒªãƒ¼ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚"});

                const contents = formatHistoryForGemini(tempHistory);
                const url = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:streamGenerateContent?alt=sse&key=${encodeURIComponent(geminiApiKey)}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: contents,
                        systemInstruction: { parts: [{ text: "ã‚ãªãŸã¯å„ªç§€ãªæ›¸è¨˜ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼ã§ã™ã€‚" }] },
                        generationConfig: { temperature: 0.7 }
                    })
                });

                if (!response.ok) throw new Error("Summary Error: " + response.status);

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";
                let fullText = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop();

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;
                        const jsonStr = line.slice(6).trim();
                        if (!jsonStr || jsonStr === '[DONE]') continue;
                        let data;
                        try {
                            data = JSON.parse(jsonStr);
                        } catch (e) {
                            continue;
                        }
                        const cand = data.candidates && data.candidates[0];
                        const parts = cand && cand.content && Array.isArray(cand.content.parts) ? cand.content.parts : null;
                        if (!parts || parts.length === 0) continue;

                        for (const part of parts) {
                            if (!part || typeof part.text !== 'string') continue;
                            fullText += part.text;
                        }

                        contentSpan.innerHTML = fullText.replace(/\n/g, '<br>');
                        chatWindow.scrollTop = chatWindow.scrollHeight;
                    }
                }
                
                contentSpan.classList.remove('cursor');
                showTyping(false);

                // ã‚µãƒãƒªãƒ¼ä¿å­˜ï¼†ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæœ‰åŠ¹åŒ–
                lastSummaryText = fullText;
                buttons.exportTxt.disabled = false;
                buttons.exportDoc.disabled = false;

                buttons.startAuto.style.display = 'inline-block';
                buttons.startAuto.innerText = 'ğŸ”„ æ–°ã—ã„è­°è«–ã‚’å§‹ã‚ã‚‹';

            } catch (e) {
                showTyping(false);
                addErrorMessage(`ã¾ã¨ã‚ä½œæˆã‚¨ãƒ©ãƒ¼: ${e.message}`);
            }
        }

        // --- ã‚µãƒãƒªãƒ¼ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ ---
        function downloadSummaryAs(ext) {
            if (!lastSummaryText) {
                alert("ã‚µãƒãƒªãƒ¼ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
                return;
            }
            const blob = new Blob([lastSummaryText], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `summary.${ext}`;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }

        // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---

        function createMessageDiv(role) {
            const div = document.createElement('div');
            div.classList.add('chat-message');
            
            const roleClassMap = {
                "ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼": "role-moderator",
                "ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ": "role-market",
                "ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚¿ãƒ¼": "role-translator",
                "ã‚¢ã‚»ãƒƒãƒˆãƒ»ã‚¹ã‚«ã‚¦ãƒˆ": "role-scout",
                "ãƒ“ã‚¸ãƒã‚¹ãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼": "role-creator",
                "ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ»ã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆ": "role-expert"
            };

            div.classList.add(roleClassMap[role] || 'role-system');
            
            const roleTitle = document.createElement('strong');
            roleTitle.innerText = role;
            div.appendChild(roleTitle);
            
            chatWindow.appendChild(div);
            return div;
        }

        function addMessageToChat(role, content) {
            const div = createMessageDiv(role);
            const span = document.createElement('span');
            span.innerHTML = content.replace(/\n/g, '<br>');
            div.appendChild(span);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function addSystemMessage(text) {
            const div = document.createElement('div');
            div.classList.add('role-system');
            div.innerText = text;
            chatWindow.appendChild(div);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function addErrorMessage(text) {
            const div = document.createElement('div');
            div.classList.add('role-error');
            div.innerText = text;
            chatWindow.appendChild(div);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        function showTyping(show, roleName = '') {
            typingIndicator.style.display = show ? 'block' : 'none';
            if (show) {
                typingIndicator.innerText = `${roleName} ãŒè€ƒãˆä¸­...`;
            }
        }

        function updateTurnDisplay() {
            turnDisplay.innerText = currentTurnCount;
        }

        function formatHistoryForOpenAI(history) {
            return history.map(item => {
                if (item.role === "ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ»ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ" || item.role === "ãƒ“ã‚¸ãƒã‚¹ãƒ»ã‚¯ãƒªã‚¨ã‚¤ã‚¿ãƒ¼") {
                    return { role: "assistant", content: item.content };
                }
                return { role: "user", content: `[${item.role}]: ${item.content}` };
            });
        }

        function formatHistoryForGemini(history) {
            const contents = [];
            for (const item of history) {
                if (["ãƒ‡ã‚£ã‚¹ã‚«ãƒƒã‚·ãƒ§ãƒ³ãƒ»ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚¿ãƒ¼", "ãƒ†ã‚¯ãƒãƒ­ã‚¸ãƒ¼ãƒ»ãƒˆãƒ©ãƒ³ã‚¹ãƒ¬ãƒ¼ã‚¿ãƒ¼", "ã‚¢ã‚»ãƒƒãƒˆãƒ»ã‚¹ã‚«ã‚¦ãƒˆ"].includes(item.role)) {
                    contents.push({ role: "model", parts: [{ text: item.content }] });
                } else {
                    contents.push({ role: "user", parts: [{ text: `[${item.role}]: ${item.content}` }] });
                }
            }
            return contents;
        }

    </script>
</body>
</html>
