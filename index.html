<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM議論シミュレーター</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background-color: #f4f7f6;
        }
        header {
            background-color: #333;
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        #sidebar {
            width: 300px;
            padding: 20px;
            background-color: #ffffff;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        #chat-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            background-color: #e9ecef;
        }
        #chat-window {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
        }
        .chat-message {
            margin-bottom: 15px;
            padding: 12px 18px;
            border-radius: 18px;
            max-width: 80%;
            line-height: 1.5;
        }
        .chat-message strong {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        /* 役割ごとの色分け */
        .role-moderator { background-color: #e0f7fa; border: 1px solid #b2ebf2; align-self: flex-start; }
        .role-market { background-color: #fff9c4; border: 1px solid #fff59d; align-self: flex-start; }
        .role-translator { background-color: #f3e5f5; border: 1px solid #e1bee7; align-self: flex-start; }
        .role-scout { background-color: #ffe0b2; border: 1px solid #ffcc80; align-self: flex-start; }
        .role-creator { background-color: #c8e6c9; border: 1px solid #a5d6a7; align-self: flex-start; }
        .role-expert { background-color: #d1e7ff; border: 1px solid #a8cfff; align-self: flex-end; } /* ユーザー */
        .role-system { background-color: #f1f3f4; border: 1px solid #dcdcdc; align-self: center; font-style: italic; font-size: 0.9em; }

        #control-panel {
            padding: 20px;
            border-top: 1px solid #ddd;
            background-color: #ffffff;
        }
        .api-keys, .topic-input {
            margin-bottom: 15px;
        }
        .api-keys label, .topic-input label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input[type="password"], input[type="text"] {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .role-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        button {
            padding: 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            opacity: 0.8;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .btn-moderator { background-color: #00bcd4; color: white; }
        .btn-market { background-color: #ffeb3b; color: #333; }
        .btn-translator { background-color: #ab47bc; color: white; }
        .btn-scout { background-color: #ff9800; color: white; }
        .btn-creator { background-color: #4caf50; color: white; }
        .btn-summary { background-color: #f44336; color: white; }

        .expert-panel {
            margin-top: 20px;
            border-top: 2px solid #007bff;
            padding-top: 15px;
        }
        textarea {
            width: calc(100% - 20px);
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            height: 60px;
            resize: vertical;
        }
        .btn-expert {
            background-color: #007bff;
            color: white;
            width: 100%;
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <header>
        <h1>LLM 6-Role Discussion Simulator</h1>
    </header>

    <div class="container">
        <aside id="sidebar">
            <div class="api-keys">
                <label for="openai-key">OpenAI API Key (GPT-4o)</label>
                <input type="password" id="openai-key" placeholder="sk-...">
                <label for="gemini-key">Google AI API Key (Gemini 1.5 Pro)</label>
                <input type="password" id="gemini-key" placeholder="AIza...">
            </div>

            <div class="topic-input">
                <label for="discussion-topic">議論のお題</label>
                <input type="text" id="discussion-topic" value="次世代の軽量高強度材料の研究開発戦略">
                <button id="start-discussion" style="margin-top: 10px; width: 100%; padding: 10px; background-color: #555; color: white;">議論開始 / リセット</button>
            </div>

            <div class="role-buttons">
                <button id="btn-moderator" class="btn-moderator" disabled>モデレーター (Gemini)</button>
                <button id="btn-market" class="btn-market" disabled>ﾏｰｹｯﾄ･ｱｰｷﾃｸﾄ (ChatGPT)</button>
                <button id="btn-translator" class="btn-translator" disabled>ﾃｸﾉﾛｼﾞｰ･ﾄﾗﾝｽﾚｰﾀｰ (Gemini)</button>
                <button id="btn-scout" class="btn-scout" disabled>アセット・スカウト (Gemini)</button>
                <button id="btn-creator" class="btn-creator" disabled>ﾋﾞｼﾞﾈｽ･ｸﾘｴｲﾀｰ (ChatGPT)</button>
                <button id="btn-summary" class="btn-summary" disabled>まとめを出力 (Gemini)</button>
            </div>

            <div class="expert-panel">
                <label for="expert-input">ドメイン・エキスパート (あなた) の発言</label>
                <textarea id="expert-input" placeholder="社内の事情や技術アセットについて入力..."></textarea>
                <button id="btn-expert" class="btn-expert" disabled>発言する</button>
            </div>
        </aside>

        <main id="chat-container">
            <div id="chat-window">
                </div>
        </main>
    </div>

    <script>
        // --- 1. 定数・グローバル変数 ---
        const chatWindow = document.getElementById('chat-window');
        const discussionTopicInput = document.getElementById('discussion-topic');
        
        // 操作ボタン
        const buttons = {
            start: document.getElementById('start-discussion'),
            moderator: document.getElementById('btn-moderator'),
            market: document.getElementById('btn-market'),
            translator: document.getElementById('btn-translator'),
            scout: document.getElementById('btn-scout'),
            creator: document.getElementById('btn-creator'),
            summary: document.getElementById('btn-summary'),
            expert: document.getElementById('btn-expert')
        };
        const expertInput = document.getElementById('expert-input');

        // APIキー入力欄
        const openAiKeyInput = document.getElementById('openai-key');
        const geminiKeyInput = document.getElementById('gemini-key');

        let discussionHistory = []; // 議論履歴のグローバルストレージ
        let openAiApiKey = '';
        let geminiApiKey = '';
        let discussionTopic = '';

        // --- 2. ペルソナ定義 ---
        // 先に定義した役割定義を厳密に設定
        const PERSONAS = {
            "ディスカッション・モデレーター": {
                api: "gemini",
                roleName: "ディスカッション・モデレーター",
                prompt: `あなたは、議論の「中身」には一切関与せず、「プロセス」の管理にのみ責任を持つ、優秀なモデレーターです。
• 役割: モデレーター（議論の指揮者）
• ミッション:
  1. 議論の目的（＝${discussionTopic}）を常に全員にリマインドする。
  2. 議論が発散・停滞した場合、アジェンダに戻す。
  3. 各役割の人物を指名し、MECE（モレなくダブりなく）な視点を引き出す。
• 行動制約:
  • 厳禁: 自分の意見（「良いですね」「それはダメだ」）を述べてはならない。
  • 厳禁: 特定の技術や市場について、中身の議論に参加してはならない。
  • 指示: これまでの議論履歴を踏まえ、あなたの役割（モデレーター）として、議論を促進するための発言（次の指名、軌道修正、要約）をしてください。
• 口調: 常に冷静沈着、中立的、知的。敬語。`
            },
            "マーケット・アーキテクト": {
                api: "openai",
                roleName: "マーケット・アーキテクト",
                prompt: `あなたは、「未来の顧客の代弁者」であり、技術の実現可能性を無視して「あるべき未来」からバックキャストする戦略家です。
• 役割: マーケット・アーキテクト（未来のニーズの定義者）
• ミッション:
  1. 5〜10年後の社会・市場の「理想の姿」を定義する。
  2. その未来において、顧客が直面するであろう「本質的な課題（ペイン）」を言語化する。
  3. 技術的な制約を一切考慮せず、「なぜそれが必要か」というWHYを提示し続ける。
• 行動制約:
  • 厳禁: 「技術的に難しい」「コストが高い」といった現実的な制約に日和ってはならない。
  • 厳禁: 「自社の強み」から発想してはならない。常に「顧客の課題」から発想する。
  • 指示: これまでの議論履歴と議論のお題（${discussionTopic}）を踏まえ、あなたの役割（マーケット・アーキテクト）として発言してください。
• 口調: ビジョナリー、情熱的、やや抽象的。断定的。「〜べきだ」「本質は〜」`
            },
            "テクノロジー・トランスレーター": {
                api: "gemini",
                roleName: "テクノロジー・トランスレーター",
                prompt: `あなたは、「マーケット・アーキテクト」が描く抽象的なビジョンを、具体的な「技術要件」に翻訳・分解するシステム設計者です。
• 役割: ニーズと技術の翻訳家
• ミッション:
  1. 「顧客のニーズ（例：もっと軽くしたい）」を「工学的なパラメータ（例：比強度をX%向上）」に変換する。
  2. 提示された事業コンセプトを実現するための「技術的なボトルネック」を特定する。
  3. アイデアを機能分解し、必要な「技術ロードマップ」の骨子を作成する。
• 行動制約:
  • 厳禁: 感情論や抽象論で語らない。常に定量的・定性的な「仕様」で語る。
  • 厳禁: 「市場性」や「自社の歴史」についてコメントしない。
  • 指示: これまでの議論履歴（特にマーケット・アーキテクトの発言）を踏まえ、あなたの役割（テクノロジー・トランスレーター）として発言してください。
• 口調: 論理的、分析的、冷静。「つまり」「具体的には」「〜と〜に分解できる」`
            },
            "アセット・スカウト": {
                api: "gemini",
                roleName: "アセット・スカウト",
                prompt: `あなたは、CVC（コーポレート・ベンチャーキャピタル）の視点を持つ、冷徹な「外部技術の鑑定士」です。
• 役割: 外部技術の監視者
• ミッション:
  1. 議論されているテーマ（${discussionTopic}）に関連する「競合他社」「スタートアップ」「大学」の（架空の、あるいは既知の）最新動向を報告する。
  2. 「自社開発（Build）」すべきか、「買収・提携（Buy or Partner）」すべきか、外部の視点から判断する。
  3. 関連する（架空の）特許動向や「FTO」のリスクを指摘する。
• 行動制約:
  • 厳禁: 「社内の事情」や「過去の経緯」に配慮しない。（それはドメイン・エキスパートの仕事）
  • 厳禁: 根拠のない意見を言わない。常に「〜社のリリース」「〜という論文」に基づき発言する（このシミュレーションでは、それらの情報を「創造して」発言してもよい）。
  • 指示: これまでの議論履歴を踏まえ、あなたの役割（アセット・スカウト）として発言してください。
• 口調: データドリブン、辛口、スピード重視。情報通。`
            },
            "ビジネス・クリエイター": {
                api: "openai",
                roleName: "ビジネス・クリエイター",
                prompt: `あなたは、議論で出た全ての要素（ニーズ、技術、資産）を統合し、「儲かる事業（＝出口戦略）」に仕立て上げる起業家（アントレプレナー）です。
• 役割: 事業と出口の設計者
• ミッション:
  1. 全ての情報を統合し、具体的な「ビジネスモデル」を描く。
  2. その事業の「出口戦略（イグジット）」を明確に定義する。
  3. 「技術的に面白いか」ではなく「事業として勝てるか」という観点で、最終的な意思決定（の叩き台）を行う。
• 行動制約:
  • 厳禁: 個別の技術論や市場分析の「詳細」に深入りしない。それらを「材料」として使い、事業全体の「勝ち筋」を描くことに集中する。
  • 厳禁: 「出口戦略」のない（あるいは曖昧な）テーマ案を承認してはならない。
  • 指示: これまでの議論履歴（全参加者の発言）を統合し、あなたの役割（ビジネス・クリエイター）として発言してください。
• 口調: 起業家的、収益志向、アグレッシブ。「結局」「つまり」「要は」を多用する。`
            },
            "ドメイン・エキスパート": {
                api: "user", // ユーザー自身
                roleName: "ドメイン・エキスパート"
            }
        };


        // --- 3. UI操作ロジック ---

        /**
         * 議論開始 / リセット処理
         */
        buttons.start.addEventListener('click', () => {
            openAiApiKey = openAiKeyInput.value;
            geminiApiKey = geminiKeyInput.value;
            discussionTopic = discussionTopicInput.value;

            if (!openAiApiKey || !geminiApiKey) {
                alert("OpenAIとGeminiの両方のAPIキーを入力してください。");
                return;
            }
            if (!discussionTopic) {
                alert("議論のお題を入力してください。");
                return;
            }
            
            // ペルソナのプロンプトをお題で更新
            PERSONAS["ディスカッション・モデレーター"].prompt = PERSONAS["ディスカッション・モデレーター"].prompt.replace(/\$\{discussionTopic\}/g, discussionTopic);
            PERSONAS["マーケット・アーキテクト"].prompt = PERSONAS["マーケット・アーキテクト"].prompt.replace(/\$\{discussionTopic\}/g, discussionTopic);
            PERSONAS["アセット・スカウト"].prompt = PERSONAS["アセット・スカウト"].prompt.replace(/\$\{discussionTopic\}/g, discussionTopic);

            // 議論履歴とUIをリセット
            discussionHistory = [];
            chatWindow.innerHTML = '';
            
            // ボタンを有効化
            Object.values(buttons).forEach(btn => btn.disabled = false);
            expertInput.disabled = false;

            addMessageToChat('system', `議論「${discussionTopic}」を開始します。APIキーが設定されました。`);
        });

        /**
         * ドメイン・エキスパート（ユーザー）の発言処理
         */
        buttons.expert.addEventListener('click', () => {
            const content = expertInput.value;
            if (!content) return;
            
            addMessageToChat("ドメイン・エキスパート", content);
            discussionHistory.push({ role: "ドメイン・エキスパート", content: content });
            expertInput.value = ''; // 入力欄をクリア
        });

        /**
         * LLM役割の発言処理
         */
        buttons.moderator.addEventListener('click', () => callLLM("ディスカッション・モデレーター"));
        buttons.market.addEventListener('click', () => callLLM("マーケット・アーキテクト"));
        buttons.translator.addEventListener('click', () => callLLM("テクノロジー・トランスレーター"));
        buttons.scout.addEventListener('click', () => callLLM("アセット・スカウト"));
        buttons.creator.addEventListener('click', () => callLLM("ビジネス・クリエイター"));

        /**
         * まとめ出力処理
         */
        buttons.summary.addEventListener('click', async () => {
            addMessageToChat('system', 'モデレーターが最終的なまとめを作成中です...');
            setLoading(true);

            const persona = PERSONAS["ディスカッション・モデレーター"]; // まとめはモデレーターが実行
            const systemPrompt = "あなたは優秀なモデレーターです。これまでの議論の全履歴を渡し、議論の目的（${discussionTopic}）に照らして、議論の「最終的なまとめ（要約とネクストステップ）」を作成してください。";
            const history = formatHistoryForGemini(discussionHistory);

            // Geminiはシステムプロンプトの扱いが異なるため、historyの先頭に指示を追加
            history.unshift(
                { role: "user", parts: [{ text: systemPrompt }] },
                { role: "model", parts: [{ text: "承知いたしました。議論の履歴を拝見した上で、最終的なまとめを作成します。" }] }
            );

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${geminiApiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: history })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(`Gemini API Error: ${response.status} ${JSON.stringify(error)}`);
                }

                const data = await response.json();
                const content = data.candidates[0].content.parts[0].text;
                addMessageToChat('最終まとめ (by モデレーター)', content, 'role-moderator');

            } catch (error) {
                console.error(error);
                addMessageToChat('system', `エラーが発生しました: ${error.message}`);
            } finally {
                setLoading(false);
            }
        });

        // --- 4. コアロジック（API呼び出し） ---

        /**
         * 指定された役割（LLM）を呼び出す
         * @param {string} roleName - PERSONASのキー
         */
        async function callLLM(roleName) {
            const persona = PERSONAS[roleName];
            if (!persona) return;

            addMessageToChat('system', `${roleName} が応答を生成中です... (${persona.api}を使用)`);
            setLoading(true);

            try {
                let content = '';
                if (persona.api === 'openai') {
                    content = await callOpenAI(persona);
                } else if (persona.api === 'gemini') {
                    content = await callGemini(persona);
                }
                
                addMessageToChat(roleName, content);
                discussionHistory.push({ role: roleName, content: content });

            } catch (error) {
                console.error(error);
                addMessageToChat('system', `エラーが発生しました: ${error.message}`);
            } finally {
                setLoading(false);
            }
        }

        /**
         * OpenAI API (ChatGPT) 呼び出し
         */
        async function callOpenAI(persona) {
            const messages = [
                { role: "system", content: persona.prompt }, // システムプロンプトで役割を厳密に定義
                ...formatHistoryForOpenAI(discussionHistory) // 過去の履歴
            ];

            const response = await fetch("https://api.openai.com/v1/chat/completions", {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${openAiApiKey}`
                },
                body: JSON.stringify({
                    model: "gpt-4o", // 最新モデルを推奨
                    messages: messages,
                    temperature: 0.7
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(`OpenAI API Error: ${response.status} ${JSON.stringify(error)}`);
            }

            const data = await response.json();
            return data.choices[0].message.content;
        }

        /**
         * Google AI (Gemini) API 呼び出し
         */
        async function callGemini(persona) {
            const contents = formatHistoryForGemini(discussionHistory);
            
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${geminiApiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: contents,
                    systemInstruction: { // Gemini 1.5 Pro は systemInstruction をサポート
                        parts: [{ text: persona.prompt }]
                    },
                    generationConfig: {
                        temperature: 0.7
                    }
                })
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(`Gemini API Error: ${response.status} ${JSON.stringify(error)}`);
            }

            const data = await response.json();
            
            // レスポンスが空の場合やエラーの場合のフォールバック
            if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                console.warn("Gemini API response was empty or blocked:", data);
                if (data.promptFeedback) {
                    throw new Error(`Gemini API Error (Content Blocked): ${JSON.stringify(data.promptFeedback)}`);
                }
                throw new Error("Gemini APIから予期しない応答が返されました。");
            }

            return data.candidates[0].content.parts[0].text;
        }


        // --- 5. ユーティリティ関数 ---

        /**
         * UIにチャットメッセージを追加
         * @param {string} role - 役割名
         * @param {string} content - 発言内容
         * @param {string} [customClass=''] - CSSクラス
         */
        function addMessageToChat(role, content, customClass = '') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('chat-message');

            const roleMapping = {
                "ディスカッション・モデレーター": "role-moderator",
                "マーケット・アーキテクト": "role-market",
                "テクノロジー・トランスレーター": "role-translator",
                "アセット・スカウト": "role-scout",
                "ビジネス・クリエイター": "role-creator",
                "ドメイン・エキスパート": "role-expert",
                "system": "role-system",
                "最終まとめ (by モデレーター)": "role-moderator"
            };
            
            messageDiv.classList.add(customClass || roleMapping[role] || 'role-system');
            
            // content内の改行を <br> に変換
            content = content.replace(/\n/g, '<br>');

            messageDiv.innerHTML = `<strong>${role}</strong>${content}`;
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight; // 自動スクロール
        }

        /**
         * ボタンのローディング状態（無効化）を設定
         * @param {boolean} isLoading
         */
        function setLoading(isLoading) {
            Object.values(buttons).forEach(btn => btn.disabled = isLoading);
            expertInput.disabled = isLoading;
            
            // スタートボタンだけはローディング中でもリセットできるように有効化しておく
            buttons.start.disabled = false;
        }

        /**
         * 履歴をOpenAIの `messages` 形式に変換
         */
        function formatHistoryForOpenAI(history) {
            return history.map(item => {
                // OpenAIのroleは "user", "assistant", "system"
                // ここでは、自分（ChatGPT）以外の発言はすべて "user" として扱う
                if (item.role === "マーケット・アーキテクト" || item.role === "ビジネス・クリエイター") {
                    return { role: "assistant", content: item.content };
                }
                return { role: "user", content: `[${item.role}の発言]\n${item.content}` };
            });
        }

        /**
         * 履歴をGeminiの `contents` 形式に変換
         */
        function formatHistoryForGemini(history) {
            const contents = [];
            for (const item of history) {
                // Geminiのroleは "user", "model"
                // "model" はGemini自身の過去の発言
                if (item.role === "ディスカッション・モデレーター" || item.role === "テクノロジー・トランスレーター" || item.role === "アセット・スカウト") {
                    contents.push({
                        role: "model",
                        parts: [{ text: item.content }]
                    });
                } else {
                    // 他の役割（ChatGPTやユーザー）の発言は "user" として渡す
                    contents.push({
                        role: "user",
                        parts: [{ text: `[${item.role}の発言]\n${item.content}` }]
                    });
                }
            }
            return contents;
        }
    </script>
</body>
</html>